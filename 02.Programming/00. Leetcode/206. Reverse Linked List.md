# Thinking

Recursive approach
1. Save head.next to temp, remove head.next 
2. reverse temp
3. append head to tail of temp
4. return the temp's head
# My solution without any input

### V1:
Code:
```js
var reverseList = function(head) {
    // Recursive approach
    // 1. Save head.next to temp, remove head.next 
    // 2. reverse temp
    // 3. append head to tail of temp
    // 4. return the temp's head
    if(!head){return head;}
    if(!head.next){return head;}
    let temp = head.next;
    head.next = null;
    temp = reverseList(temp);
    let newHead = temp;
    while(temp.next){
        temp = temp.next;
    }
    temp.next = head;
    return newHead;

};
```
Explanation:
It works, yet poor performance.
The while next part cost a lot.

```js
var reverseList = function(head) {
    // Iterative appraoch
    if(!head || !head.next){return head;}

    let current = head;
    let prev = null;
    while(current){
        let next = current.next;
        current.next = prev;
        prev = current;
        current = next;
    }
    return prev;
};
```
Solution in programming 101, just manipulating pointer backward.

# My solution After studying others answer

### V1: 
Input: 28ms sample
```js
var reverseList = function(head) {
let prev=null;
let curr=head;
while(curr !== null){
    const nextNode = curr.next;
    curr.next=prev;
    prev= curr;
    curr=nextNode;
}
return prev;
};
```

1. His code is nearly identical to mine, by running his code, the performance varies and doesn't met 28ms.
2. Note that the checking head part is unnecessary, because if head is null, it
