# Thinking



# My solution without any input

### V1:
Code:
```js
var majorityElement = function(nums) {
    // Goal: O(1), only need one loop to finish
    // 1. iterate and count each occurence
    // 2. pick the largest
    // 3. O(n) complete
    const count = nums.reduce(function (acc, curr) {
        return acc[curr] = (acc[curr] || 0) + 1, acc
    }, {});

	let maxKey = Object.keys(count)[0];
    let maxNum = Object.values(count)[0]
    for(let keys in count){
        if(count[keys] > maxNum){
            maxNum = count[keys];
            maxKey = keys;
        }
    }

    return maxKey;
};
```
Explanation:

Count and return the largest one. 
# My solution with conceptual Input

### V1: 
Input:
**Boyer-Moore Majority Vote Algorithm**, A linear major vote algo

Prompt: Explain Boyer-Moore Majority Vote Algorithm without code
###### Here is what ChatGPT saids:
The Boyer-Moore Majority Vote Algorithm is an efficient algorithm for finding the majority element in a sequence of elements, ==provided that the majority element (appearing more than n/2 times==, where n is the length of the sequence) exists. The algorithm was proposed by Robert S. Boyer and J Strother Moore in 1981.

The key idea behind the Boyer-Moore Majority Vote Algorithm is to cancel out pairs of different elements. The algorithm maintains two variables: a candidate and a counter. It iterates through the elements in the sequence, updating the candidate and counter based on the current element.

Here's a step-by-step explanation of the algorithm:

1. **Initialization:**
   - Set the candidate to an arbitrary element.
   - Set the counter to 1.

2. **Iterating through the sequence:**
   - For each element in the sequence:
     - If the counter is 0, set the candidate to the current element and reset the counter to 1.
     - If the current element is equal to the candidate, increment the counter.
     - If the current element is different from the candidate, decrement the counter.

3. **Verification:**
   - After iterating through the entire sequence, the candidate variable holds a potential majority element.
   - Run a second pass through the sequence to count the occurrences of the candidate.
   - ==If the count of the candidate is greater than n/2==, where n is the length of the sequence, then the candidate is the majority element.

The reason this algorithm works is based on the fact that if there is a majority element, it will survive the cancellation process and be left as the final candidate. The algorithm cancels out non-majority elements in a way that ensures the majority element will still be present in the end.

The Boyer-Moore Majority Vote Algorithm has a time complexity of O(n) and a space complexity of O(1), making it a very efficient solution for finding the majority element in a sequence.


Code:
```js

```
Explanation::

# My solution After studying others answer

### V1: 
Input:
```js

```
Code:
```js

```
Explanation: