
# Thinking
Two valid case
1. root + L/R has child P/Q
2. L + R
One invalid case:
Both p and q on same subtree (need search deeper)

Problem1: How to know a subtree contain P/Q => hasfunction\
Problem2: How to know it efficiently (looping 2 will traverse the node under, therefore repeat scanning), has table?


# My solution without any input

### V1:
Code:
```js
let hasNode = function(root,target) {
    if (root === target)
        return true;
    if (root == null)
        return false;
    return hasNode(root.left,target) || hasNode(root.right,target);
}

var lowestCommonAncestor = function(root, p, q) {

    while(root){

        // Valid case 1
        if(root === p){
            if(hasNode(root.left,q)|| hasNode(root.right,q))
                return root;
        }
        if(root === q){
            if(hasNode(root.left,p)|| hasNode(root.right,p))
                return root;
        }

        // Valid vase 2
        let leftAndRightAreTargets = (hasNode(root.left,p) && hasNode(root.right,q)) || (hasNode(root.left,q) && hasNode(root.right,p));
        if(leftAndRightAreTargets){
            return root;
        }

        // Invalid case 1
        if(hasNode(root.left,p) && hasNode(root.left,q)){
            console.log("left")
            root = root.left;
        }else if(hasNode(root.right,p) && hasNode(root.right,q)){
            console.log("right")
            root = root.right;
        }
    }

};
```
![](../../z.Images/Pasted%20image%2020230527032159.png)Explanation:
- There are two valid case that a node is the ancestor
	1. The root and left/right 
	2. Left and Right are the targeted Child


# My solution with conceptual Input

### V1: 
Input:
Code:
```js

```
Explanation::

# My solution After studying others answer

### V1: 
Input:
```js

```
Code:
```js

```
Explanation::